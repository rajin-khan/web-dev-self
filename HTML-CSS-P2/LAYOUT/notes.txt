T1: THE BOX MODEL

all elements that are rendered are put in an invisible box. that box has, from the inside:

content, (outside which is the)
padding, (outside which is the)
border, (outside which is the)
margin.

padding is the space between the content and the border, whereas the margin is the area between the border and everything else.
the padding property works exactly like the border property. it takes 4 values, (top, right, bottom, left).
for example:

padding: 10px, 20px, 10px, 20px;

shortcut - padding: 10px, 20px;
why?
similar to border property, if you drop the last value (left) then thr browser will assign the righ one's value to the left one.
similary, if bottom value absent, top value used to represent it.

say you have two paragraph elements with a margin of 20px. then the margins on the bottom of the first paragraph and the top of the second one
will get collapsed (become one). so in total, the space will be 20px.

whereas, if you had padding set to 20px, you would have 40px in between (20 for the bottom of the first p, 20 for the top of the first p).
the padding does not collapse.

so, you should use the margin property to space out elements.
and the padding property to seperate the space between the border and the content element.


T2: SIZING ELEMENTS 


say we use a box again, with the properties:

.box {

    height: 100px;
    width: 100px;
    background-color: gold;
}

we have to realize that by default, the height and the width properties affect the content area ONLY.
thus we will see a 100x100 box.
let's add more properties.

.box {

    height: 100px;
    width: 100px;
    background-color: gold;
    padding: 20px;
    border: 10px solid orange;
}

we see now a 160x160 box. why? the padding on left and right of 20px, and border of 10px made the width 160. vertical padding and border did the same.
adding the padding and the border made the visible box get bigger. so, we need to take away that padding makes the visible box bigger
(padding takes the color of the content).
border also makes the visible box bigger.

however, margin MOVES the box AWAY from other boxes. it does not impact the size of the visible box.

to get rid of this weird behaviour, we can use the box-sizing property. if we set it to:

box-sizing: border-box;

this will make the entire box, padding, border and all fit within the original height and width (100x100). this means that
now our content box has been reduced by: (horizontal padding: 20, 20, horizontal border: 10, 10, so content width is now 100-40-20=40)
                                         (vertical padding: 20, 20, vertical border: 10, 10, so content height is now 100-40-20=40)
                                        now content is 40x40.

now, keeping the box-sizing property and removing the padding and border would make the content area 100x100 to fit the height and width.
but we don't wanna apply this property to every single html element one by one. this is where we use:

the universal selector "*" (be careful when using it)

so at the top of the css doc, we can just add:

* {

    box-sizing: border-box;
}

now this will assign this property to all html elements, EXCEPT FOR THE PSEUDO ELEMENTS ("::"). to fix this, we can just change it like this:

*, *::before, *::after {

    box-sizing: border-box;
}

so now this will target all elements, and things before and after those elements.

now, keep in mind, the height and width properties are only applied to BLOCK LEVEL ELEMENTS (take up the entire available horizontal space)

let's say in the html file, we replaced the div with a span for two boxes. then it would just become two highlighted words next to each other.
this is because span is an inline element, and inline elements don't respect the height and width properties.
but what if we want to give an inline element a width and height?
this is where we use:

the display property. it makes it so that the height and width we specify are followed by inline and/or block level elements.

so in the .box part, we can insert the display peroperty. it takes three types of values: inline/block/inline-block.

.box {

    height: 100px;
    width: 100px;
    background-color: gold;
    display: inline-block; //this makes it so that both inline elements and block level elements respect the width and height properties.
}

in the html, if the spans are in diff lines, there will be a space in between the blocks. if they are right next to each other, they will be completely
attached.


T3: OVERFLOWING


sometimes, our container may not be able to fit all the content we provide it. in this case, overflowing may happen.
for example, in a div class box of size 150x150, we put in a p element of 50 words. it might not fit. so, in the box, we add the:

overflow property.

so the overflow property takes a lot of values:
visible (it shows everything that's overflowing) / hidden (it hides the extra content) / scroll (we can see two scroll bars for hor and ver scroll)
         / auto (to only show scroll bars when needed.)
so in the box, it looks like this:

.box {

    border: 3px solid gold;
    width: 150px;
    height: 150px;
    overflow: auto;
}

now, the overflow property is a shorthand for two overflow properties. namely,

overflow-x, and 
overflow-y.

if we use just overflow, it will be used for both directions. sometimes we wanna have more control. then we use those.
this it can also be:

.box {

    border: 3px solid gold;
    width: 150px;
    height: 150px;
    overflow: hidden auto; //it is hiding the horizontal scroll bar, and just showing the vertical one
}


T4: MEASUREMENT UNITS


so war, we've only used pixels to size elements.

but, we have absolute, and relative unit 

absolute:

    px 


relative:

    % (relative to the size of the parent element/container)

    vw
        (relative to the size of the viewport)
    vh

    em 
        (relative to the font size)
    rem 

now, if we use px, it will remain the same size regardless of what device or window you're viewing it on. thus, some say it should never be used, because
it is not scalable. but, it does have its own applications (for example, maybe border values)

say we have a div class called box and we've given it the following properties:

body {

}

.box {

    width: 50%;
    height: 100px;
    background-color: gold;
}

here, using 50% for the width means it is 50% of the size of the parent element. since this div's parent element is the body element, it will depend on
the size of the body element (as specified above it).
as the body element is a block level element, it takes up the entire width of the page by default (as no size is specified). 
thus, setting the width of the box to 50% means that it will take up half the width of the page.
now, if we resize the window, the size will change accordingly. this is the benefit of using relative measurement units.

now, what if we wanted to make the box take up 100% of the vertical space, it would make sense to use height: 100%. but, it doesn't work. this is because
the parent element of the box is the body element, and it is a block level element. by default, block level elements have a height of 0 and only take
up space when there is content in it (like the body element). thus, here, we need to use viewport units (vw/vh).

thus, we can now use this:

.box {

    width: 50vw; (meaning viewport width)
    height: 100vh; (meaning viewport height)
    background-color: gold;
}

additionally, em units mean that it will take nx the size of the font of that element. (if it doesn't have a font size assigned, it goes up to the 
next root element, if that doesn't have it, it keeps going up, till it reaches the basic HTML font size, which is 16px). since it can get complicated
to follow these things, we can use rem units.
so 10rem would mean that the width/height will always be 10x the size of the font of the root html element (always 16px unless stated otherwise).
15rem would mean 15x the font size. but that calculation can get complicated. so, we can use this method:

html {

    font-size: 62.5% //this makes it so that the root html font size is 10px, so now our rem calculations are always 10x whatever we give it.
}

after this modification to the css sheet, 15rem means 150px, and so on. the benefit of using these units is that if a user changes the browser view zoom %,
the width and height of the box adjust accordingly.


T5: POSITIONING


tip: each element can have multiple classes separated by a space. like this:

<div class="boxes">
        <div class="box box-one"></div>
        <div class="box box-two"></div>
        <div class="box box-three"></div>
 </div>

 so, to start off, we have three boxes in a container:

 .boxes {

    border: 3px solid lightgrey;
}

.box {

    width: 5rem;
    height: 5rem;
}

.box-one {

    background-color: gold;
}

.box-two {

    background-color: tomato;
}

.box-three {

    background-color: dodgerblue;
}

so, to start positioning elements here, we can enable the:

position 

property.

the position value of all elements is set to static by default. (which means it stays in its normal position, usually top left)
we change the property of the position to :
relative (positioning), 
which will move it relative to its static(original) position.
so, say we wanna change the position property of box-two:

.box-two {

    background-color: tomato;
    position: relative;
    left: 5rem; //this means we're adding 5rems of space to the left of the box (we have left: right: top: and bottom:)
    //if we happened to se this value to -5rem, we'd add 5 rems of space to the right side of the box, which would make it appear off screen.
}

negative values may be useful when we want elements to initially remain off screen and then appear using animations and whatnot.
here, we're using rem just cause. we can use any unit, like %, vw/vh/px/em it doesn't matter.

one box is not affected by the positioning of other element boxes. we have overlapping if something goes over the position of another.
now, if one box overlaps another, and you don't like the order of their overlapping, you can change this in the settings of the DOM. we do this by
using the:

z-index

property. it is exactly how it sounds, almost like x, y, and z axes where the z-index controls the positioning of the "depth" of the webpage, kind
of like controlling what goes front and what goes back. by default, the z-index property of all elements is 0. if you set it to a positive value,
like say 1, it moves "closer" to us. if we set it to a negative value, it moves "away" from us.

box two was initially overlapping and coming over box 1. we wanted to change that. so:

.box-two {

    background-color: tomato;
    position: relative;
    left: 4rem;
    bottom: 4rem;
    z-index: -1;
}

it doesn't matter if you use 1, 7, 99, 100, or 99999. What matters is that the bigger the number is, the higher up it will move along the z axis,
or closer to us, so to speak.
vice versa with negative values.


this was all relative positioning. (we can move an element relative to its normal position, not impacting other elements on the page.)
in contrast, we have:
absolute (positioning),
which will move the elements relative to its container.
to do this, first you MUST set the position property of the CONTAINER to relative. in our case, we'd edit the .boxes style like this:

 .boxes {

    border: 3px solid lightgrey;
    position: relative;
}

so now, we can change the box-two position property to absolute:

.box-two {

    background-color: tomato;
    position: absolute;
    right: 0; //by the way, when using 0, you don't need to specify any unit
    bottom: 0;
    z-index: -1;
}

notice how when you look at the webpage, the (blue) box-three moved up and remained on the left even though it was supposed to be below the (tomato) box-two.
this is because when we absolutely position an element, it breaks it from the normal flow of the page. from the parent's point of view, they don't exist.
the absolutely positioned elements exist on a second layer to them. thus, the parent element only sees two boxes (one/yellow and three/blue).
the orange box is on a different layer (not the same as changing z property tho). all the other elements are rendered as if the absolutely positioned element
does not exist.


sometimes you might wanna position an element relative to the viewport (e.g, sometimes you might wanna have a navbar at the top no matter what)
this is when we set the position property to:
fixed,
which positions the element relative to the viewport/area of the browser.

like this:

.box-two {

    background-color: tomato;
    position: fixed;
    top: 0;
    z-index: 999999;
}

so far, we've been using either top, bottom, left, or right separately to configure the positions of boxes. now, we can also use a combination of these.
for example:

.box-two {

    background-color: tomato;
    position: fixed;
    left: 2rem;
    right: 2rem;
    width: auto; //this is to let the browser figure out what the width should be so that space that we allocated to the left and right fit accordingly.
    //otherwise, just the left part will work and not the right, bc our box was originally set to just 5rem, so it wouldn't reach the right side far enough
    //for the right space to come into effect.
    z-index: 999999;
}

also, i figured this out:

.box-two {

    background-color: tomato;
    position: fixed;
    top: 0;
    left: 25vw; //this means 25% of the viewport width's space is given to the left side
    right: 25vw; //and same for the right side. so, in total, the box is now taking up the remaining 50% of th middle space.
    //if both left and right were set to 50, the box would just disappear
    width: auto; //for this combo thing to work, the width MUST be set to auto. (so if we wanted to leave spaces on the top and bottom, we'd HAVE to set the height to auto too)
    z-index: 999999;
}

T6: FLOATING ELEMENTS

not too important, but still used, so talked about. floating elements usually do not appear to the parent class. thus, we have an issue called parent collapsing.
what happens is, the parent element does not see the floating element, so for example a border that is set around a box and a text might not see the box if it is floating. thus the border does not wrap around it. this is border collapsing. we can fix the issue by creating an empty div at the end to make the box extend to that length. but this is an informal solution and not recommended. it is better to use pseudo elements and add it at the end of the parent element in css, like
.tweet::after, or .clearfix::after (as it is more commonly called). .clear is a property used to define any other elements in the class to appear after the floating element. we use clear: left; to clear a floating element on the left, and clear:right; to clear a floating element on the right. it is more common to use clear:both; to avoid confusion.

again, floating elements were used in the past, but it is generally quite complicated to do so, with the making of things like flexbox.

T7: FLEXBOX

allows us to lay out elements in a horizontal/vertical direction without having to use too many complicated properties.
say we have a div container containing 3 boxes, like this:

<div class="container">
        <div class="box">A</div>
        <div class="box">B</div>
        <div class="box">C</div>
</div>

then, in the css, we'd first have to enable the flex property in the parent element (container):

.container {

    border: 3px solid lightgrey;
    display: flex; //here
}

then we'd have to add the arrangement type:

.container {

    border: 3px solid lightgrey;
    display: flex;
    flex-direction: column; //here, we can do flex-direction: row, column-reverse, or even row-reverse
}

now, flex has 2 axes, the main (primary) axis, and the cross (secondary) axis.
depending on how you set the flex-direction property, (row/column), you can determine what the main/cross axis is.

if the direction is row, the main axis is the horizontal axis. the cross axis is the vertical axis.
if the direction is column, the main axis is the vertical axis. the cross axis is the horizontal axis.

now, to align items, we need to remember two properties:

- justify-content (to align items along the main axis)
- align-items (to align items along the cross axis)

these properties can have the values:

    flex-start (default)
    flex-end
    center
    space-evenly
    space-between
    space-around

for example:

.container {

    border: 3px solid lightgrey;
    height: 90vh;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
} 

now, what about align-content?
it only works if we have multiple lines in our flex container.

now we have added multiple boxes to the container, like this:

<div class="container">
    <div class="box">A</div>
    <div class="box">B</div>
    <div class="box">C</div>
    <div class="box">D</div>
    <div class="box">E</div>
    <div class="box">F</div>
    <div class="box">G</div>
    <div class="box">H</div>
</div>

to fit them all in one line, by default, flex makes the boxes shrink to fit it all in one line.
we can change this behaviour using the:

flex-wrap 

property. we can set the flex-wrap to:

    nowrap (default)
    wrap (makes the items keep their original side, and go to the next line in the container if needed)

now, since we have items on two lines, we can use the align-content property, like this:

.container {

    border: 3px solid lightgrey;
    height: 90vh;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    align-content: center;
} 

now, let's go back to three boxes.
what if we wanted to specifically align box A so that it was at the start of the vertical axis?
then we'd have to assign it a different class, then under that class, we define a new rule of:

align-self: (flex-start/end, center, all that stuff) like this:

.box-one {

    align-self: flex-start;
}

and now the rules for that one object specifically can be edited/changed, overwriting the align-items rule.

that was all about positioning items in flex. now, we'll get into sizing items with flex.
for sizing items, we have a few properties in flex:

flex-basis (determines the initial size of the item)
has the value:
    auto (default)
    but we can also use sizing units like vh, vw, rem to determine the size.

it is VERY IMPORTANT to remember that flex-basis is determined on the flex-direction. 
if direction is row, flex basis determines the WIDTH.
if direction is column, flex basis determines the HEIGHT.

of course, we can apply the flex-basis property to individual items as well by creating a different class for them.


flex-grow (makes the items grow in size according to available space)
has the value:
    0 (default, boxes not growing)
    but we can also use values like 1, 2, 3 and so on.

how it works is, all the available space is taken up so that each box defines 1 unit of space. so for 3 boxes, it takes up all the space so that 3 boxes can fit.
say we individually gave box-one a flex-grow value of 2, and the others 1. then out of 4 units, box-one would take up 2/4ths of the total space, with the rest being 1/4th.

flex-shrink (makes the items shrink in size according to available space)
(opposite of flex-grow)

all these properties should be applied to the ITEMS, not the flex container.

now, a combination of all these properties is the simple "flex" property.
it works like this:

flex: 1 1 15rem; (if we give 3 values, 1st will be flex-grow, then flex-shrink, then flex-basis at the end. if just 2 values, it's flex-grow, then flex-basis)